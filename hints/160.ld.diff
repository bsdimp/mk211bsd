--- root-2.10.1/usr/src/bin/ld.c	1988-08-14 02:09:04.000000000 -0600
+++ root-2.11/usr/src/bin/ld.c	2020-06-22 14:56:24.230734000 -0600
@@ -254,6 +254,7 @@
 long	ladd();
 int	delexit();
 long	lseek();
+long	atol();
 char	*savestr();
 char	*malloc();
 char	*mktemp();
@@ -542,9 +543,10 @@
 	case 1:
 		error(-1,
 "warning: archive has no table of contents; add one using ranlib(1)");
-		nloc = 1;
+		nloc = SARMAG;
 		while (step(nloc))
-			nloc += (archdr.ar_size + sizeof(archdr) + 1) >> 1;
+			nloc += sizeof(archdr) +
+			    round(atol(archdr.ar_size), sizeof (short));
 		break;
 
 	/*
@@ -555,15 +557,25 @@
 	 * when there is a table of contents!)
 	 */
 	case 2:
-		tnum = archdr.ar_size / sizeof(struct tab);
-		if (tnum >= TABSZ)
-			error(1, "toc buffer too small");
-		lseek(infil, (long)(sizeof(filhdr.a_magic) + sizeof(archdr)), 0);
-		read(infil, (char *)tab, tnum * sizeof(struct tab));
+		nloc = SARMAG + sizeof (archdr);
+		dseek(&text, nloc, sizeof (tnum));
+		mget((char *)&tnum, sizeof (tnum), &text);
+		nloc += sizeof (tnum);
+		tab = (struct ranlib *)malloc(tnum);
+		if (tab == 0)
+			error(1, "ran out of memory (toc)");
+		dseek(&text, nloc, tnum);
+		mget((char *)tab, tnum, &text);
+		nloc += tnum;
+		tnum /= sizeof (struct ranlib);
+		dseek(&text, nloc, sizeof (ssiz));
+		mget((char *)&ssiz, sizeof (ssiz), &text);
+		nloc += sizeof (ssiz);
 		while (ldrand())
-			;
-		libp->loc = -1;
-		libp++;
+			continue;
+		free((char *)tab);
+		free(tabstr);
+		nextlibp(-1);
 		break;
 
 	/*
@@ -573,9 +585,10 @@
 	case 3:
 		error(-1,
 "warning: table of contents for archive is out of date; rerun ranlib(1)");
-		for (nloc = 1 + ((archdr.ar_size + sizeof(archdr) + 1) >> 1);
-		    step(nloc);
-			nloc += (archdr.ar_size + sizeof(archdr) + 1) >> 1);
+		nloc = SARMAG;
+		do
+			nloc += (sizeof(archdr) + atol(archdr.ar_size)) >> 1;
+		while (step(nloc));
 		break;
 	}
 	close(infil);
@@ -590,37 +603,66 @@
 step(nloc)
 	off_t nloc;
 {
-	dseek(&text, nloc, sizeof archdr);
+
+	dseek(&text, nloc, (long) sizeof archdr);
 	if (text.size <= 0) {
-		libp->loc = -1;
-		libp++;
+		nextlibp(-1);
 		return (0);
 	}
-	mget((int *)&archdr, sizeof archdr);
-	if (load1(1, nloc + (sizeof archdr) / 2)) {
-		libp->loc = nloc;
-		libp++;
-		if (Mflag)
-			printf("\t%s\n", archdr.ar_name);
-	}
+	getarhdr();
+	if (load1(1, nloc + (sizeof archdr)))
+		nextlibp(nloc);
 	return (1);
 }
 
+/*
+ * Record the location of a useful archive member.
+ * Recording -1 marks the end of files from an archive.
+ * The liblist data structure is dynamically extended here.
+ */
+nextlibp(val)
+	off_t val;
+{
+
+	if (clibseg->li_used == NROUT) {
+		if (++clibseg == &libseg[NSEG])
+			error(1, "too many files loaded from libraries");
+		clibseg->li_first = (off_t *)malloc(NROUT * sizeof (off_t));
+		if (clibseg->li_first == 0)
+			error(1, "ran out of memory (nextlibp)");
+	}
+	clibseg->li_first[clibseg->li_used++] = val;
+	if (val != -1 && Mflag)
+		printf("\t%s\n", archdr.ar_name);
+}
+
+/*
+ * One pass over an archive with a table of contents.
+ * Remember the number of symbols currently defined,
+ * then call step on members which look promising (i.e.
+ * that define a symbol which is currently externally undefined).
+ * Indicate to our caller whether this process netted any more symbols.
+ */
 ldrand()
 {
-	register int i;
-	register SYMBOL *sp, **pp;
-	LIBLIST *oldp = libp;
+	register struct nlist *sp, **hp;
+	register struct ranlib *tp, *tplast;
+	off_t loc;
+	int nsymt = symx(nextsym);
 
-	for(i = 0; i < tnum; i++) {
-		if ((pp = slookup(tab[i].cname)) == 0)
+	tplast = &tab[tnum-1];
+	for (tp = tab; tp <= tplast; tp++) {
+		if ((hp = slookup(tp->ran_un.ran_name)) == 0 || *hp == 0)
 			continue;
-		sp = *pp;
+		sp = *hp;
 		if (sp->n_type != N_EXT+N_UNDF)
 			continue;
-		step(tab[i].cloc >> 1);
+		step(tp->ran_off);
+		loc = tp->ran_off;
+		while (tp < tplast && (tp+1)->ran_off == loc)
+			tp++;
 	}
-	return(oldp != libp);
+	return (symx(nextsym) != nsymt);
 }
 
 /*
@@ -629,10 +671,12 @@
 load1(libflg, loc)
 	off_t loc;
 {
-	register SYMBOL *sp;
-	int savindex;
-	int ndef, type, mtype;
-	long nlocal;
+	register struct nlist *sp;
+	struct nlist *savnext;
+	int ndef, nlocal, type, size, nsymt;
+	register int i;
+	off_t maxoff;
+	struct stat stb;
 
 	readhdr(loc);
 	if (filhdr.a_syms == 0) {
@@ -640,27 +684,39 @@
 			return (0);
 		error(1, "no namelist");
 	}
+	if (libflg)
+		maxoff = atol(archdr.ar_size);
+	else {
+		fstat(infil, &stb);
+		maxoff = stb.st_size;
+	}
+	if (N_STROFF(filhdr) + sizeof (off_t) >= maxoff)
+		error(1, "too small (old format .o?)");
 	ctrel = tsize; cdrel += dsize; cbrel += bsize;
 	ndef = 0;
-	nlocal = sizeof cursym;
-	savindex = symindex;
-	if ((filhdr.a_flag&RELFLG)==1) {
-		error(1, "No relocation bits");
-		return(0);
-	}
-	loc += (sizeof filhdr)/2 + filhdr.a_text + filhdr.a_data;
-	dseek(&text, loc, (int)filhdr.a_syms);
+	nlocal = sizeof(cursym);
+	savnext = nextsym;
+	loc += N_SYMOFF(filhdr);
+	dseek(&text, loc, filhdr.a_syms);
+	dseek(&reloc, loc + filhdr.a_syms, sizeof(off_t));
+	mget(&size, sizeof (size), &reloc);
+	dseek(&reloc, loc + filhdr.a_syms+sizeof (off_t), size-sizeof (off_t));
+	curstr = (char *)malloc(size);
+	if (curstr == NULL)
+		error(1, "no space for string table");
+	mget(curstr+sizeof(off_t), size-sizeof(off_t), &reloc);
 	while (text.size > 0) {
-		mget((int *)&cursym, sizeof cursym);
-		type = cursym.n_type;
-		if (Sflag) {
-			mtype = type&037;
-			if (mtype==1 || mtype>4) {
-				continue;
-			}
+		mget((char *)&cursym, sizeof(struct nlist), &text);
+		if (cursym.n_un.n_strx) {
+			if (cursym.n_un.n_strx<sizeof(size) ||
+			    cursym.n_un.n_strx>=size)
+				error(1, "bad string table index (pass 1)");
+			cursym.n_un.n_name = curstr + cursym.n_un.n_strx;
 		}
+		type = cursym.n_type;
 		if ((type&N_EXT)==0) {
-			if (Xflag==0 || cursym.n_name[0]!='L')
+			if (Xflag==0 || cursym.n_un.n_name[0]!='L' ||
+			    type & N_STAB)
 				nlocal += sizeof cursym;
 			continue;
 		}
@@ -679,24 +735,30 @@
 		ndef++;
 		sp->n_type = cursym.n_type;
 		sp->n_value = cursym.n_value;
-		sp->sovly = ((sp->n_type &~ N_EXT) == N_TEXT) ? curov : 0;
-		if (trace)
-			printf("%8.8s type 0%o in overlay %u at %u\n",
-			    sp->n_name, sp->n_type, sp->sovly, sp->n_value);
 	}
 	if (libflg==0 || ndef) {
-		tsize = add(tsize,filhdr.a_text,"text overflow");
-		dsize = add(dsize,filhdr.a_data,"data overflow");
-		bsize = add(bsize,filhdr.a_bss,"bss overflow");
-		ssize = ladd(ssize,nlocal,"symbol table overflow");
+		tsize += filhdr.a_text;
+		dsize += round(filhdr.a_data, sizeof (long));
+		bsize += round(filhdr.a_bss, sizeof (long));
+		ssize += nlocal;
+		trsize += filhdr.a_trsize;
+		drsize += filhdr.a_drsize;
+		if (funding)
+			textbase = (*slookup("_end"))->n_value;
+		nsymt = symx(nextsym);
+		for (i = symx(savnext); i < nsymt; i++) {
+			sp = xsym(i);
+			sp->n_un.n_name = savestr(sp->n_un.n_name);
+		}
+		free(curstr);
 		return (1);
 	}
 	/*
 	 * No symbols defined by this library member.
 	 * Rip out the hash table entries and reset the symbol table.
 	 */
-	while (symindex>savindex)
-		*symhash[--symindex]=0;
+	symfree(savnext);
+	free(curstr);
 	return(0);
 }
 
@@ -913,7 +975,7 @@
 	} else {	/* scan archive members referenced */
 		for (lp = libp; lp->loc != -1; lp++) {
 			dseek(&text, lp->loc, sizeof archdr);
-			mget((int *)&archdr, sizeof archdr);
+			getarhdr();
 			mkfsym(archdr.ar_name);
 			load2(lp->loc + (sizeof archdr) / 2);
 		}
@@ -1091,7 +1153,8 @@
 {
 	register u_int n, *p;
 	register SYMBOL *sp, *symp;
-
+	long before, after;
+ 
 	if (numov) {
 		/* int aovno = adrof("__ovno");		XXX KB */
 		int aovhndlr[NOVL+1];
@@ -1127,6 +1190,9 @@
 		copy(&troutb);
 		copy(&droutb);
 	}
+
+	flush(&toutb);
+	before = lseek(toutb.fildes , 0L, 1);
 	if (sflag==0) {
 		if (xflag==0)
 			copy(&soutb);
@@ -1146,7 +1212,27 @@
 			p++;
 		}
 	}
+/*
+ * the following is a workaround ("kludge") to insure that the
+ * correct size of the symbol table is written to the header.  this
+ * was occasioned by noticing that the value of a_syms for /unix showed
+ * 0115200 (39552) instead of 0115544 (39780).  somewhere 19 symbols were
+ * not being counted - (oh where oh where have the symbols gone...?;-))
+ * but they were being written out!  Granted, it is not proper to
+ * treat the symptom instead of the problem, but this works, and if you
+ * fix it for real i'd like a copy of ld.c - Steven M. Schultz
+ *
+ * I really think this should be calculated anyhow, makes as much sense
+ * as trying to maintain counts everywhere else.
+*/
+
 	flush(&toutb);
+	after = lseek(toutb.fildes, 0L, 1);
+	lseek(toutb.fildes, 0L, 0);
+	read(toutb.fildes, &filhdr, sizeof (filhdr));
+	filhdr.a_syms = after - before;
+	lseek(toutb.fildes, 0L, 0);
+	write(toutb.fildes, &filhdr, sizeof (filhdr));
 	close(toutb.fildes);
 	if (!ofilfnd) {
 		unlink("a.out");
@@ -1171,6 +1257,18 @@
 
 }
 
+getarhdr()
+{
+	register char *cp;
+
+	mget((char *)&archdr, sizeof archdr, &text);
+	for (cp=archdr.ar_name; cp<&archdr.ar_name[sizeof(archdr.ar_name)];)
+		if (*cp++ == ' ') {
+			cp[-1] = 0;
+			return;
+		}
+}
+
 mget(aloc, an)
 int *aloc;
 {
@@ -1251,6 +1349,7 @@
 getfile(acp)
 char *acp;
 {
+	char arcmag[SARMAG+1];
 	struct stat stb;
 
 	archdr.ar_name[0] = '\0';
@@ -1266,18 +1365,20 @@
 	page[0].nuser = page[1].nuser = 0;
 	text.pno = reloc.pno = (PAGE *)&fpage;
 	fpage.nuser = 2;
-	dseek(&text, 0L, 2);
+	dseek(&text, 0L, SARMAG);
 	if (text.size <= 0)
 		error(1, "premature EOF");
-	if (get(&text) != ARMAG)
-		return (0);			/* regular file */
-	dseek(&text, 1L, sizeof archdr);	/* word addressing */
+	mget((char *)arcmag, SARMAG);
+	arcmag[SARMAG] = 0;
+	if (strcmp(arcmag, ARMAG))
+		return (0);
+	dseek(&text, SARMAG, sizeof archdr);
 	if (text.size <= 0)
-		return (1);			/* regular archive */
-	mget((int *)&archdr, sizeof archdr);
+		return (1);
+	getarhdr();
 	if (strncmp(archdr.ar_name, "__.SYMDEF", sizeof(archdr.ar_name)) != 0)
-		return (1);			/* regular archive */
-	return (stb.st_mtime > archdr.ar_date ? 3 : 2);
+		return (1);
+	return (stb.st_mtime > atol(archdr.ar_date) ? 3 : 2);
 }
 
 /*
