#!/bin/sh

# Vars
TOP=$(pwd)
TUHS=$HOME/tuhs
UCB=$TUHS/Distributions/UCB
TOOLS=${TOP}/tools
TOOLBIN=$TOOLS/bin
APOUT_SRC=${TOOLS}/apout
APOUT=${APOUT_SRC}/apout
TAPE211=${TOP}/tape211
ROOT211=${TOP}/root211
TAPE2101=${TOP}/tape2101
ROOT2101=${TOP}/root2101
PATCHSRC=${UCB}/2.11BSD/Patches
PATCHDIR=${TOP}/patches
HINTSDIR=${TOP}/hints
APOUT_ROOT=/

extract_dump() {
    # Even with this icky code, this is imperfect: symlinks don't work
    local r fn inode

    r=$1
    $APOUT $TOOLBIN/dumpdir f $r | tail +5 | grep -v /dev/ | fgrep -v .. | \
	( while read inode fn; do
	      fn=${fn#/}
	      case $fn in
		  */.)
		      mkdir ${fn%%/.} ;;
		  *)
		      echo 1 | $APOUT $TOOLBIN/restor xf $r ${fn}
		      mv $inode $fn
		      ;;
	      esac
	  done )
    # restor is impefect and leaves divots behind
    rm -f rst*
}

cleanup() {
    # Cleanup old stuff -- we recreate it all from extant artifacts with this script
    # and some helpers
    chmod -R +w $TAPE211 $TOOLS $ROOT211 $TAPE2101 $ROOT2101
    rm -rf $TAPE211 $TOOLS $ROOT211 $TAPE2101 $ROOT2101 ${PATCHDIR}
}

mktools() {
    # Create tools areas
    mkdir -p $TOOLS $TOOLBIN

    # We need to use the pdp-11 a.out user-mode emulator.  Copy it from the
    # unix-jun72 effort and build.
    (
	rm -rf $APOUT_SRC
	mkdir -p $APOUT_SRC
	cd $APOUT_SRC
	cp ${TUHS}/Distributions/Research/Dennis_v1/unix72/tools/apout/* .
	# fixes to make it happier with restor
	patch -p1 < $TOP/apout.patch
	make clean
	# gcc fails for me so force clang
	make CC=clang apout
    )

    # Need to extract two helper programs. We use the actual 2.11 binaries to
    # minimize porting and maximize compatibility. This assumes that we have a
    # libarchive based tar. Thankfully, TUHS has an easy to get copy of
    # the most use version of these programs.
    tar xvf ${UCB}/2.11BSD/root.afio.gz sbin/dumpdir sbin/restor
    mv sbin/* $TOOLBIN
    rmdir sbin
}

unpack_211() {
    #
    # Unpack the pl195 tape. This is a series of files needed to bootstreap 2.11BSD
    #	The format of a 2.11BSD boot tape is:
    #
    #	File	Blocksize	Content
    #	0	512		mtboot
    #		512		mtboot
    #		512		boot
    #	1	1024		disklabel.bin
    #	2	1024		mkfs.bin
    #	3	1024		restor.bin
    #	4	1024		icheck.bin
    #	5	10240		root.dmp	/ dump, need to use restor to get files
    #	6	10240		usr.tar		/usr w/o /usr/src or /usr/include
    #	7	10240		sys.tar		/usr/src/sys /usr/src/include
    #	8	10240		src.tar		/usr/src/{everything-else}
    # 
    [ -d $TAPE211 ] || (
	mkdir $TAPE211
	cd $TAPE211
	tar xvf ${UCB}/2.11BSD-pl195.tar
	gunzip root.dmp.gz
    )

    # Now 'fake' install the 2.11BSD system into $ROOT211. This does nothing to
    # configure the 'image'. The patches touch the entire directory tree, so
    # this is the easiest way to cope. But looking at the shell below, it's
    # far from the cleanest way to do this...
    [ -d $ROOT211 ] || (
	mkdir $ROOT211
	cd $ROOT211
	# can't use TAPE211 because paths grow too long
	extract_dump ../tape211/root.dmp
	# symlinks don't work, but they are important for the reverse patching,
	# so fix all known ones. Thankfully, all of them extract with a file
	# containing a path to the target. There's others in the system, but
	# tar gets them right.
	for i in vmunix sys etc/termcap etc/crash bin/sort; do
	    ln -sf $(cat $i) $i
	done
	mkdir usr
	(
	    cd usr
	    tar xvf $TAPE211/usr.tar.gz	# restore /usr
	    mkdir src
	    cd src
	    tar xvf $TAPE211/sys.tar.gz	# restore /usr/src/sys and /usr/src/include
	    tar xvf $TAPE211/src.tar.gz	# rest of /usr/src
	)

	# Some 'fixes' for things that make this root less pure, but that allow
	# for the patch process to work.

	# big hammer, make this relative
	ln -sf usr/src/sys sys
	# This messes up permissions, but lets more patches succeed.
	chmod -R +w $ROOT211
    )
}

unpack_2101() {
    #
    # As we reconstruct, we'll need some files from 2.10.1.
    #
    # Tape 1
    # File	RecSize	   #Recs	Content
    # ----	-------    -----	-------
    # 0	512	   41		tapeboot,tapeboot,boot
    # 1	1024	   28		mkfs
    # 2	1024	   27		restor
    # 3	1024	   26		icheck
    # 4	10240	   451		dump of root fs
    # 5	10240	   2277		tar of /usr without usr/src
    # 6	10240	   466		tar of /usr/src/{sys,include}
    # Tape 2
    # File	RecSize	   #Recs	Content
    # ----	-------    -----	-------
    # 0	10240	   3959		tar of /usr without /usr/src
    #	The exact tape files are in the two directories 'tape1' and 'tape2'
    #	respectively.  The files have been gzip'd to save space.
    #	In the directory 'root' is the unpacked version of the system.
    #
    # Turns out that the source is extracted wrong in the root file, leading to confusion,
    # so we'll do the whole thing we do for 2.11 for convenience.
    #
    (
	mkdir $TAPE2101
	cd $TAPE2101
	tar xvf ${UCB}/2.10.1bsd.tar
	gunzip tape1/file4.gz		# root.dump file
    )

    # Now 'fake' install the 2.10.1BSD system into $ROOT2101. This does nothing to
    # configure the 'image'. The patches touch the entire directory tree, so
    # this is the easiest way to cope. But looking at the shell below, it's
    # far from the cleanest way to do this...
    (
	mkdir $ROOT2101
	cd $ROOT2101
	extract_dump ../tape2101/tape1/file4
	# symlinks don't work, so fix all known ones. Thankfully, all of them
	# extract with a file containing a path to the target. There's others in
	# the system, but tar gets them right.
	for i in vmunix sys etc/termcap etc/crash bin/sort; do
	    ln -sf $(cat $i) $i
	done
	mkdir usr
	(
	    cd usr
	    tar xvf $TAPE2101/tape1/file5.gz	# restore /usr
	    mkdir src
	    cd src
	    tar xvf $TAPE2101/tape1/file6.gz	# restore /usr/src/sys and /usr/src/include
	    tar xvf $TAPE2101/tape2/file0.gz	# rest of /usr/src
	)
    )
}

extract_patches() {
    (
	mkdir $PATCHDIR
	cd $PATCHDIR
	for i in $(jot 20 0); do
	    j=$(printf %02d $i)
	    tar xvf $PATCHSRC/${j}0-${j}9.tar.bz2
	done
	# we're at patch 195, so remove the rest
	rm -f 196 197 198 199
    )
}

# Set the stage
[ -n "$FORCE_CLEAN" ] && cleanup
[ -d $TOOLS ] || mktools
unpack_211
[ -d $ROOT2101 ] || unpack_2101
[ -d $PATCHDIR ] || extract_patches

#
# OK. Now we have a good root for both 2.10.1BSD and 2.11pl195BSD with patches
# extracted.  We can start to walk them backwards to get back to the 2.11 as
# shipped, or as close as we can come to that in the absence of actual extant
# artifacts.
#
# If these were modern patches, then we'd just do patch -R 195 times. However,
# they aren't.  There's a number of files that were lost in this process since
# the instructions have you do things like in patch 180:
#
# Save the text below into a temporary file (/tmp/foo).  Then:
#	1) cd /tmp
#	2) sh foo
#	3) patch -p0 < m4.man.patch
#	4) mv /usr/src/usr.bin/m4 /usr/src/usr.bin/m4.old
#	   (or optionally you can simply "rm -r /usr/src/usr.bin/m4")
#	5) sh m4.shar
#	6) rm foo m4.man.patch m4.shar
#	7) cd /usr/src/usr.bin/m4
#	8) make
#	9) make install
#	10) cd /usr/src/man/man1
#	11) /usr/man/manroff m4.1 > /usr/man/cat1/m4.0
#
# Step 4 is the information destorying step. The old m4 src directory is gone
# and not preserved. Thankfully, in most (all?) of these cases we can consult
# 2.10.1BSD to get the files. Sometimes we can cross check them (like patch
# 153 which has us transform the old sources into the new and then patches them
# so we can check that the 'old sources' we recreate produce the same results.
# In this case it could be ambiguos, but it turns out not to be).
#
# So, this means that we'll need to proceed carefully. These are shar files, and
# we don't want anything in them to affect the host system.
#

patches=$(cd $PATCHDIR; ls | sort -rn)

for p in $patches; do
    echo -n "$p "
    case $p in
	*.tar)
	    echo tarball of patches
	    ;;
	*)
	    if grep -q '^#! */bin/sh' $PATCHDIR/$p; then
		echo shar
		exit 1
	    else
		echo simple patch
		(
		    cd $ROOT211
		    if [ -r $HINTSDIR/${p}.setup ] ; then
			. $HINTSDIR/${p}.setup
		    fi
		    patch -R -p1 < $PATCHDIR/$p
		)
	    fi
	    ;;
    esac
done
