#!/bin/sh

# Vars
TOP=$(pwd)
TUHS=$HOME/tuhs
UCB=$TUHS/Distributions/UCB
TOOLS=${TOP}/tools
TOOLBIN=$TOOLS/bin
APOUT_SRC=${TOOLS}/apout
APOUT=${APOUT_SRC}/apout
TAPE211=${TOP}/tape-2.11
ROOT211=${TOP}/root-2.11
TAPE2101=${TOP}/tape-2.10.1
ROOT2101=${TOP}/root-2.10.1
PATCHSRC=${UCB}/2.11BSD/Patches
PATCHDIR=${TOP}/patches
HINTSDIR=${TOP}/hints
APOUT_ROOT=/
TEMP=${TOP}/tmp
LOGS=${TOP}/log
RECOVERY_LOG=${LOGS}/recovery.log
ROOT211TAR=$TOP/root-2.11.tar.xz

export APOUT_ROOT

die() {
    echo $*
    exit 1
}

extract_dump() {
    # Even with this icky code, this is imperfect: symlinks don't work
    local r fn inode

    r=$1
    $APOUT $TOOLBIN/dumpdir f $r | tail +5 | grep -v '/dev/[a-z]' | fgrep -v .. | \
	( while read inode fn; do
	      fn=${fn#/}
	      case $fn in
		  */.)
		      mkdir ${fn%%/.} ;;
		  *)
		      echo 1 | $APOUT $TOOLBIN/restor xf $r ${fn}
		      mv $inode $fn
		      ;;
	      esac
	  done )
    # restor is impefect and leaves divots behind
    rm -f rst*
}

cleanup() {
    # Cleanup old stuff -- we recreate it all from extant artifacts with this script
    # and some helpers
    chmod -R +w $TAPE211 $TOOLS $ROOT211 $TAPE2101 $ROOT2101
    rm -rf $TAPE211 $TOOLS $ROOT211 $TAPE2101 $ROOT2101 ${PATCHDIR}
}

mktools() {
    # Create tools areas
    mkdir -p $TOOLS $TOOLBIN

    # We need to use the pdp-11 a.out user-mode emulator.  Copy it from the
    # unix-jun72 effort and build.
    (
	rm -rf $APOUT_SRC
	mkdir -p $APOUT_SRC
	cd $APOUT_SRC
	cp ${TUHS}/Distributions/Research/Dennis_v1/unix72/tools/apout/* .
	# fixes to make it happier with restor
	patch -p1 < $TOP/apout.patch
	make clean
	# gcc fails for me so force clang
	make CC=clang apout
    )

    # Need to extract two helper programs. We use the actual 2.11 binaries to
    # minimize porting and maximize compatibility. This assumes that we have a
    # libarchive based tar. Thankfully, TUHS has an easy to get copy of
    # the most use version of these programs.
    tar xvf ${UCB}/2.11BSD/root.afio.gz sbin/dumpdir sbin/restor
    mv sbin/* $TOOLBIN
    rmdir sbin
}

unpack_211() {
    #
    # Unpack the pl195 tape. This is a series of files needed to bootstreap 2.11BSD
    #	The format of a 2.11BSD boot tape is:
    #
    #	File	Blocksize	Content
    #	0	512		mtboot
    #		512		mtboot
    #		512		boot
    #	1	1024		disklabel.bin
    #	2	1024		mkfs.bin
    #	3	1024		restor.bin
    #	4	1024		icheck.bin
    #	5	10240		root.dmp	/ dump, need to use restor to get files
    #	6	10240		usr.tar		/usr w/o /usr/src or /usr/include
    #	7	10240		sys.tar		/usr/src/sys /usr/src/include
    #	8	10240		src.tar		/usr/src/{everything-else}
    # 
    [ -d $TAPE211 ] || (
	mkdir $TAPE211
	cd $TAPE211
	tar xvf ${UCB}/2.11BSD-pl195.tar
	gunzip root.dmp.gz
    )

    # Now 'fake' install the 2.11BSD system into $ROOT211. This does nothing to
    # configure the 'image'. The patches touch the entire directory tree, so
    # this is the easiest way to cope. But looking at the shell below, it's
    # far from the cleanest way to do this...
    # Also, have a kludge for running this a bunch where we just restore the
    # root from the cached tarball...
    if [ -d $ROOT211 ] ; then
	if [ -r $ROOT211TAR ]; then
	    echo Refreshing 2.11 root from tarball
	    rm -rf $ROOT211
	    (cd $TOP ; sudo tar xf $ROOT211TAR)
	fi
    else
	(
	    mkdir $ROOT211
	    cd $ROOT211
	    # can't use TAPE211 because paths grow too long
	    extract_dump ../tape-2.11/root.dmp
	    # symlinks don't work, but they are important for the reverse patching,
	    # so fix all known ones. Thankfully, all of them extract with a file
	    # containing a path to the target. There's others in the system, but
	    # tar gets them right.
	    for i in vmunix sys etc/termcap etc/crash bin/sort; do
		ln -sf $(cat $i) $i
	    done
	    mkdir usr
	    (
		cd usr
		tar xvf $TAPE211/usr.tar.gz	# restore /usr
		mkdir src
		cd src
		tar xvf $TAPE211/sys.tar.gz	# restore /usr/src/sys and /usr/src/include
		tar xvf $TAPE211/src.tar.gz	# rest of /usr/src
	    )

	    # Some 'fixes' for things that make this root less pure, but that allow
	    # for the patch process to work.

	    # big hammer, make this relative
	    ln -sf usr/src/sys sys
	    # This messes up permissions, but lets more patches succeed.
	    chmod -R +w $ROOT211
	)
	if [ ! -r $ROOT211TAR ]; then
	    (cd $TOP ; sudo tar xf $ROOT211TAR $ROOT211)
	fi
    fi
}

unpack_2101() {
    #
    # As we reconstruct, we'll need some files from 2.10.1.
    #
    # Tape 1
    # File	RecSize	   #Recs	Content
    # ----	-------    -----	-------
    # 0	512	   41		tapeboot,tapeboot,boot
    # 1	1024	   28		mkfs
    # 2	1024	   27		restor
    # 3	1024	   26		icheck
    # 4	10240	   451		dump of root fs
    # 5	10240	   2277		tar of /usr without usr/src
    # 6	10240	   466		tar of /usr/src/{sys,include}
    # Tape 2
    # File	RecSize	   #Recs	Content
    # ----	-------    -----	-------
    # 0	10240	   3959		tar of /usr without /usr/src
    #	The exact tape files are in the two directories 'tape1' and 'tape2'
    #	respectively.  The files have been gzip'd to save space.
    #	In the directory 'root' is the unpacked version of the system.
    #
    # Turns out that the source is extracted wrong in the root file, leading to confusion,
    # so we'll do the whole thing we do for 2.11 for convenience.
    #
    (
	mkdir $TAPE2101
	cd $TAPE2101
	tar xvf ${UCB}/2.10.1bsd.tar
	gunzip tape1/file4.gz		# root.dump file
    )

    # Now 'fake' install the 2.10.1BSD system into $ROOT2101. This does nothing to
    # configure the 'image'. The patches touch the entire directory tree, so
    # this is the easiest way to cope. But looking at the shell below, it's
    # far from the cleanest way to do this...
    (
	mkdir $ROOT2101
	cd $ROOT2101
	extract_dump ../tape2.10.1/tape1/file4
	# symlinks don't work, so fix all known ones. Thankfully, all of them
	# extract with a file containing a path to the target. There's others in
	# the system, but tar gets them right.
	for i in vmunix sys etc/termcap etc/crash bin/sort; do
	    ln -sf $(cat $i) $i
	done
	mkdir usr
	(
	    cd usr
	    tar xvf $TAPE2101/tape1/file5.gz	# restore /usr
	    mkdir src
	    cd src
	    tar xvf $TAPE2101/tape1/file6.gz	# restore /usr/src/sys and /usr/src/include
	    tar xvf $TAPE2101/tape2/file0.gz	# rest of /usr/src
	)
    )
}

extract_patches() {
    [ -d $PATCHDIR ] || (
	mkdir $PATCHDIR
	cd $PATCHDIR
	for i in $(jot 19 1); do
	    j=$(printf %02d $i)
	    tar xf $PATCHSRC/${j}0-${j}9.tar.bz2
	done
	tar xf $PATCHSRC/001-009.tar.bz2
	# we're at patch 195, so remove the rest
	rm -f 196 197 198 199
    )
}

# helper routine to recover from 2.10.1BSD
from2.10.1() {
    for i; do
	echo "Recovering $i from 2.10.1BSD" >> $RECOVERY_LOG
	cp $ROOT2101/$i $ROOT211/$i
	chmod +w $ROOT211/$i
    done
}

undo_patch_level()
{
    local p patch s
    p=$1
    patch=$PATCHDIR/$p

    rm -f $LOGS/$p.log
    case $p in
	*.tar)
	    echo tarball of patches
	    exit 0
	    ;;
	*)
	    if grep -q '^#! */bin/sh' $PATCHDIR/$p; then
		# shar file were always complex, though in a few
		# degenerate cases were just extract a patch file
		# of varying names and apply it. Other times one
		# had to do more. The unshar script is expected
		# to undo all that.
		s=$HINTSDIR/${p}.unshar
		[ -r $s ] || die $p.unshar not found
		rm -rf $TEMP
		mkdir $TEMP
		cd $TEMP
		echo undoing shar with $s
		. $s 2>&1 >> $LOGS/$p.log
	    else
		echo simple patch
		(
		    cd $ROOT211
		    if [ -r $HINTSDIR/${p}.unpatch ] ; then
			# Some patches look like pure patches, but
			# in reality the instructions had people do
			# more than just apply the patch, and the
			# unpatch file is supposed to sort it out
			# either by patch -R + commands or by just
			# doing commands to restore the old state.
			echo undoing patch with ${p}.unpatch
			. $HINTSDIR/${p}.unpatch 2>&1 >> $LOGS/$p.log
		    else
			# Some patches aren't relative to the root
			# of the tree, so the setup routines allow
			# us to cd before apply the patch. Though
			# it may make sense to fold this into the
			# unpatch mechanism instead.
			if [ -r $HINTSDIR/${p}.setup ] ; then
			    echo setup to unapply $p with $p.setup
			    . $HINTSDIR/${p}.setup 2>&1 >> $LOGS/$p.log
			fi
			echo patch -R $p
			patch -V none -R -p1 < $PATCHDIR/$p 2>&1 | tee $LOGS/$p.log
		    fi
		)
	    fi
	    ;;
    esac
}

# Set the stage
[ -n "$FORCE_CLEAN" ] && cleanup
[ -d $TOOLS ] || mktools
unpack_211
[ -d $ROOT2101 ] || unpack_2101
[ -d $PATCHDIR ] || extract_patches

#
# OK. Now we have a good root for both 2.10.1BSD and 2.11pl195BSD with patches
# extracted.  We can start to walk them backwards to get back to the 2.11 as
# shipped, or as close as we can come to that in the absence of actual extant
# artifacts.
#
# If these were modern patches, then we'd just do patch -R 195 times. However,
# they aren't.  There's a number of files that were lost in this process since
# the instructions have you do things like in patch 180:
#
# Save the text below into a temporary file (/tmp/foo).  Then:
#	1) cd /tmp
#	2) sh foo
#	3) patch -p0 < m4.man.patch
#	4) mv /usr/src/usr.bin/m4 /usr/src/usr.bin/m4.old
#	   (or optionally you can simply "rm -r /usr/src/usr.bin/m4")
#	5) sh m4.shar
#	6) rm foo m4.man.patch m4.shar
#	7) cd /usr/src/usr.bin/m4
#	8) make
#	9) make install
#	10) cd /usr/src/man/man1
#	11) /usr/man/manroff m4.1 > /usr/man/cat1/m4.0
#
# Step 4 is the information destorying step. The old m4 src directory is gone
# and not preserved. Thankfully, in most (all?) of these cases we can consult
# 2.10.1BSD to get the files. Sometimes we can cross check them (like patch
# 153 which has us transform the old sources into the new and then patches them
# so we can check that the 'old sources' we recreate produce the same results.
# In this case it could be ambiguos, but it turns out not to be).
#
# So, this means that we'll need to proceed carefully. These are shar files, and
# we don't want anything in them to affect the host system.
#

patches=$(cd $PATCHDIR; ls | sort -rn)

[ -z "$STOP_BEFORE_PATCH" ] || die asked to stop

mkdir ${LOGS}
rm $RECOVERY_LOG
touch $RECOVERY_LOG
set -e
trap 'die undo patch $p failed' EXIT
export TEMP PATCHDIR ROOT211 ROOT2101
for p in $patches; do
    echo "$p"
    undo_patch_level $p
done
